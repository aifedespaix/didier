
  return (
    <>
      {items.map((o, i) => {
        const [sx, sy, sz] = o.size;
        const half = [sx / 2, sy / 2, sz / 2] as const;
        return (
          <RigidBody
            key={i}
            type="fixed"
            colliders={false}
            position={[o.pos[0], 0, o.pos[1]]}
          >
            <CuboidCollider
              args={[half[0], half[1], half[2]]}
              position={[0, half[1], 0]}
            />
            <mesh castShadow receiveShadow position={[0, half[1], 0]}>
              <boxGeometry args={[sx, sy, sz]} />
              <meshStandardMaterial color={o.color} />
            </mesh>
          </RigidBody>
        );
      })}
    </>
  );
}

type ZoomPreset = {
  radius: number; // distance from target (spherical)
  pitchDeg: number; // elevation from ground plane
  yawDeg: number; // around Y axis
};

interface CameraControllerProps {
  targetRef: React.MutableRefObject<RigidBodyApi | null>;
  follow: boolean;
  setFollow: (v: boolean) => void;
  zoomIndex: number;
  setZoomIndex: (i: number) => void;
}

function CameraController({
  targetRef,
  follow,
  setFollow,
  zoomIndex,
  setZoomIndex,
}: CameraControllerProps) {
  const { camera } = useThree();

  // Five zoom levels: 0 = far (default), 4 = close
  const presets: ZoomPreset[] = useMemo(
    () => [
      { radius: 24, pitchDeg: 62, yawDeg: 45 }, // far (default game view)
      { radius: 20, pitchDeg: 60, yawDeg: 45 },
      { radius: 16, pitchDeg: 58, yawDeg: 45 },
      { radius: 12, pitchDeg: 56, yawDeg: 45 },
      { radius: 9, pitchDeg: 54, yawDeg: 45 }, // close (see character well)
    ],
    []
  );

  // Input bindings
  useActionEvents("camera.follow.toggle", (ev) => {
    if (ev.type === "digital" && ev.phase === "pressed") setFollow((f) => !f);
  });
  useActionEvents("camera.zoom.in", (ev) => {
    if (ev.type === "digital" && ev.phase === "pressed")
      setZoomIndex((i) => Math.min(i + 1, presets.length - 1));
  });
  useActionEvents("camera.zoom.out", (ev) => {
    if (ev.type === "digital" && ev.phase === "pressed")
      setZoomIndex((i) => Math.max(i - 1, 0));
  });

  // Smooth state
  const smoothedPos = useRef(
    new Vector3(camera.position.x, camera.position.y, camera.position.z)
  );
  const smoothedLook = useRef(new Vector3(0, 0, 0));
  const targetPos = useRef(new Vector3());
  const desiredPos = useRef(new Vector3());
  const initialized = useRef(false);

  const deg2rad = (d: number) => (d * Math.PI) / 180;

  useFrame((_state, dt) => {
    const body = targetRef.current;
    const smoothing = 8; // higher = snappier
    const alpha = 1 - Math.exp(-smoothing * dt);

    // Target position (fallback 0,0,0)
    const t = body ? body.translation() : { x: 0, y: 0, z: 0 };
    const target = targetPos.current.set(t.x, t.y, t.z);

    const preset = presets[zoomIndex];
    const pitch = deg2rad(preset.pitchDeg);
    const yaw = deg2rad(preset.yawDeg);
    const horiz = Math.cos(pitch) * preset.radius;
    const offX = Math.sin(yaw) * horiz;
    const offZ = Math.cos(yaw) * horiz;
    const offY = Math.sin(pitch) * preset.radius;
    const desired = desiredPos.current.set(
      target.x + offX,
      target.y + offY,
      target.z + offZ
    );

    // Smooth towards desired
    smoothedPos.current.lerp(desired, alpha);
    smoothedLook.current.lerp(target, alpha);

    // First frame: snap without smoothing so camera aligns immediately
    if (!initialized.current) {
      smoothedPos.current.copy(desired);
      smoothedLook.current.copy(target);
      initialized.current = true;
    }

    if (follow) {
      camera.position.copy(smoothedPos.current);
      camera.lookAt(smoothedLook.current);
    }
  });

  return null;
}

export function Game() {
  const [target, setTarget] = useState<MoveTarget>(null);
  const playerRef = useRef<RigidBodyApi | null>(null);
  const [camFollow, setCamFollow] = useState<boolean>(true);
  const [zoomLevel, setZoomLevel] = useState<number>(0);

  return (
    <>
      <Canvas
        className="w-full h-full"
        camera={{ position: [4, 4, 6], fov: 50 }}
        shadows
        onCreated={({ scene, gl }) => {
          scene.background = new Color("#0e0f13");
          // DÃ©sactive le menu contextuel natif sur le canvas (right-click)
          gl.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );
        }}
      >
        <ambientLight intensity={0.5} />
        <directionalLight position={[5, 8, 5]} intensity={1.2} castShadow />

        <Physics gravity={[0, -9.81, 0]}>
          <Ground onRightClick={(x, z) => setTarget({ x, z })} />
          <Obstacles />
          <Player target={target} bodyRef={playerRef} />
        </Physics>

        {/* Marqueur de destination (UX) */}
        <TargetMarker target={target} />

        {/* MOBA-like camera controller */}
        <CameraController
          targetRef={playerRef}
          follow={camFollow}
          setFollow={setCamFollow}
          zoomIndex={zoomLevel}
          setZoomIndex={setZoomLevel}
        />
      </Canvas>

      {/* HUD: Ã©tat camÃ©ra */}
      <div
        style={{
          position: "absolute",
          left: 12,
          top: 12,
          background: "rgba(0,0,0,0.55)",
          color: "#fff",
          padding: "6px 8px",
          borderRadius: 6,
          fontSize: 12,
          pointerEvents: "none",
        }}
      >
        <div>Camera follow: {camFollow ? "ON" : "OFF"}</div>
        <div>Zoom: {zoomLevel + 1} / 5</div>
        <div style={{ opacity: 0.8 }}>Toggle: L Â· Zoom: Wheel</div>
      </div>
    </>
  );
}

function TargetMarker({ target }: { target: MoveTarget }) {
  const group = useRef<Group | null>(null);
  const ringMat = useRef<THREE.MeshStandardMaterial | null>(null);
  const fillMat = useRef<THREE.MeshStandardMaterial | null>(null);
  const spin = useRef(0);

  useFrame((_s, dt) => {
    if (!group.current) return;
    spin.current += dt;
    const s = 1 + 0.08 * Math.sin(spin.current * 6);
    group.current.scale.set(s, 1, s);
    if (ringMat.current)
      ringMat.current.opacity = 0.55 + 0.25 * Math.sin(spin.current * 7);
    if (fillMat.current)
      fillMat.current.opacity = 0.25 + 0.2 * Math.sin(spin.current * 5 + 1.2);
  });

  if (!target) return null;
  return (
    <group ref={group} position={[target.x, 0.02, target.z]}>
      {/* Anneau principal */}
      <mesh
        rotation-x={-Math.PI / 2}
        castShadow={false}
        receiveShadow={false}
        renderOrder={2}
      >
        <ringGeometry args={[0.45, 0.6, 48]} />
        <meshStandardMaterial
          ref={ringMat as any}
          color="#22d3ee"
          emissive="#0ea5b7"
          transparent
          depthWrite={false}
          opacity={0.65}
        />
      </mesh>
      {/* Disque central lÃ©ger */}
      <mesh
        rotation-x={-Math.PI / 2}
        castShadow={false}
        receiveShadow={false}
        renderOrder={2}
      >
        <circleGeometry args={[0.12, 24]} />
        <meshStandardMaterial
          ref={fillMat as any}
          color="#22d3ee"
          emissive="#0891b2"
          transparent
          depthWrite={false}
          opacity={0.35}
        />
      </mesh>
    </group>
  );
}
